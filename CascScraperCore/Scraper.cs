using System.Data;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using Antlr4.Runtime;
using CascLibCore;
using CascScraperCore.Schema;
using HeroInfoExtractor.Schema;
using HtmlAgilityPack;

namespace CascScraperCore;

public partial class Scraper {
    private const string PtrGameInstallationPath = @"C:\Program Files (x86)\Heroes of the Storm Public Test";
    private const string NormalGameInstallationPath = @"C:\Program Files (x86)\Heroes of the Storm";
    private const string GameInstallationPath = NormalGameInstallationPath;

    private static readonly Dictionary<string, string> CooldownOnExpireAbilities = new() {
        { "AlarakDeadlyChargeActivate", "AlarakDeadlyChargeExecuteSetCooldown" },
        { "DVaBoostersOn", "DVaBoostersApplyCooldown" },
        { "DVaMechDefenseMatrixOn", "DVaMechDefenseMatrixApplyCooldown" },
        { "DehakaBurrow", "DehakaBurrowSetCooldownEndModifyUnit" },
        { "GreymaneInnerBeast", "GreymaneInnerBeastModifyCooldown" },
        { "TinkerDethLazorCharged", "TinkerDethLazorModifyCooldown" },
        //{ "VarianColossusSmash", "VarianColossusSmashApplyCooldown" },
        { "LucioSoundBarrier", "LucioSoundBarrierCastCompleteModifyUnit" },
        { "MalGanisCarrionSwarm", "MalGanisCarrionSwarmCastCompleteModifyUnit" },
        //{ "UtherBenediction", "BenedictionStartCooldown" },
        { "DeckardGemRuby", "DeckardGemRubyModifyCooldown" },
        { "DeckardGemEmerald", "DeckardGemEmeraldModifyCooldown" },
        { "DeckardGemSapphire", "DeckardGemSapphireModifyCooldown" },
        { "ZagaraEnvenomedSpines", "ZagaraWeaponEnvenomedSpinesFinalModifyPlayer" },
        { "KerriganChrysalis", "KerriganChrysalisCancel" },
    };

    private static readonly string[] EntityTypes = [
        "Abil", "Behavior", "Effect", "Accumulator", "Validator", "Talent", "Unit", "Weapon", "Actor",
    ];

    private readonly Dictionary<string, XmlDocument> _referenceCatalog = [];
    private Dictionary<string, string> _allGameStrings = null!;

    private Dictionary<string, CatalogCButton> _buttonGenericDic;
    // private const string GameInstallationPath = PtrGameInstallationPath;

    // Schema generated by: https://www.liquid-technologies.com/online-xml-to-xsd-converter

    private CASCHandler _casc;
    private CASCFile _cfButtonData;
    private CASCFile _cfGameStrings;
    private CASCFolder _cfHeroes;
    private CASCFolder _cfHeromods;
    private CASCFile _cfMapData;
    private CASCFile _cfTalentData;
    private CASCFolder _cfTextures;
    private CASCFolder _fldr;

    private Dictionary<string, CatalogCTalent> _talentGenericDic;

    public List<TalentInfo> TalentInfoList { get; private set; } = [];
    public List<MapInfo> MapInfoList { get; } = [];
    public List<SkillInfo> SkillInfoList { get; } = [];
    public DataTable TalentInfoDataTable { get; set; }
    public int BuildNumber { get; private set; }
    public string BuildVersion { get; private set; }
    public Dictionary<string, ActorUnit> ActorUnits { get; } = [];
    public Dictionary<string, byte[]> HeroImages { get; } = [];
    public Dictionary<string, byte[]> MapImages { get; } = [];
    public Dictionary<string, string> MapNames { get; } = [];

    public static (CASCHandler casc, CASCFolder fldr) OpenStorage(string arg) {
        CASCConfig.LoadFlags |= LoadFlags.Install;
        var config = CASCConfig.LoadLocalStorageConfig(arg);

        var casc = CASCHandler.OpenStorage(config);

        (casc.Root as WowRootHandler)?.LoadFileDataComplete(casc);

        using (var _ = new PerfCounter("LoadListFile()")) {
            var bgWorker = new BackgroundWorkerEx {
                WorkerReportsProgress = true,
            };
            var ev = new AutoResetEvent(false);
            bgWorker.ProgressChanged += (_, e) => Console.WriteLine($"{e.ProgressPercentage} {e.UserState}");
            bgWorker.RunWorkerCompleted += (_, _) => ev.Set();
            bgWorker.DoWork += (_, _) => {
                casc.Root.LoadListFile("listfile.txt", bgWorker);
            };
            bgWorker.RunWorkerAsync();
            ev.WaitOne();
        }

        var fldr = casc.Root.SetFlags(LocaleFlags.enUS, ContentFlags.None);
        casc.Root.MergeInstall(casc.Install);

        GC.Collect();

        return (casc, fldr);
    }

    public static IEnumerable<string> ReadAllLines(Stream stream) {
        using var reader = new StreamReader(stream);
        while (reader.ReadLine() is { } line) {
            yield return line;
        }
    }

    public void FillTalentInfoList() {
        OpenCasc();

        PopulateActorUnits(_referenceCatalog["Actor"]);

        var ser2 = new XmlSerializer(typeof(Catalog));
        using (var f2 = GetFileStream(_cfTalentData)) {
            var catalog2 = (Catalog)ser2.Deserialize(f2 ?? throw new InvalidOperationException($"Can't open {_cfTalentData.FullName}"))!;
            _talentGenericDic = catalog2.CTalent.ToDictionary(x => x.id);
        }

        using (var f3 = GetFileStream(_cfButtonData)) {
            var catalog3 = (Catalog)ser2.Deserialize(f3 ?? throw new InvalidOperationException($"Can't open {_cfButtonData.FullName}"))!;
            _buttonGenericDic = catalog3.CButton.ToDictionary(x => x.id);
        }

        GetModHeroes();
        GetBaseHeroes();

        TalentInfoList = TalentInfoList.OrderBy(x => x.HeroName).ThenBy(x => x.TalentId).ToList();

        GenerateTalentInfoDataTable();

        GetMapData();
    }

    public string GenerateTalentInfoCsv() {
        var dt = TalentInfoDataTable;
        var sb = new StringBuilder();

        var columnNames = dt.Columns.Cast<DataColumn>().Select(column => column.ColumnName);
        sb.AppendLine(string.Join(",", columnNames));

        foreach (DataRow row in dt.Rows) {
            var fields = row.ItemArray.Select(
                field =>
                    string.Concat("\"", field!.ToString()!.Replace("\"", "\"\""), "\""));
            sb.AppendLine(string.Join(",", fields));
        }

        return sb.ToString();
    }

    public string GenerateTalentInfoSql() {
        var dt = TalentInfoDataTable;

        using var sqlWriter = new StringWriter();
        var tierLevels = new[] { 1, 4, 7, 10, 13, 16, 20 };
        var tierLevelsChromie = new[] { 1, 2, 5, 8, 11, 14, 18 };
        var firstLine = true;
        foreach (DataRow row in dt.Rows) {
            var hero = Escape((string)row["HeroName"]);
            var id = (int)row["TalentId"];
            var tier = (int)row["Tier"];
            var level = hero == "Chromie" ? tierLevelsChromie[tier - 1] : tierLevels[tier - 1];
            var name = Escape((string)row["TalentName"]);
            var description = Escape((string)row["TalentDescription"]);
            if (!firstLine) {
                sqlWriter.Write(",");
            }

            sqlWriter.Write($"('{hero}',{BuildNumber},{BuildNumber},{id},{level},'{name}','{description}')");
            firstLine = false;
        }

        return sqlWriter.ToString();
    }

    public string GenerateTalentInfoXml() {
        var ser = new XmlSerializer(typeof(TalentUpdatePackage));
        var today = DateTime.UtcNow.Date;
        var wednesday = today.AddDays((int)DayOfWeek.Wednesday - (int)today.DayOfWeek);

        var tup = new TalentUpdatePackage {
            Build = BuildNumber,
            Version = BuildVersion,
            Date = wednesday,
            TalentInfoList = TalentInfoList,
            MapInfoList = MapInfoList,
        };
        using var f = new StringWriter();
        ser.Serialize(f, tup);
        return f.ToString();
    }

    [GeneratedRegex("(?<!^)([A-Z])")]
    private static partial Regex CamelCaseToSpaced();

    private static string? Escape(string? s) {
        return s?.Replace("'", "\\'");
    }

    private static string FixGref(string gref) {
        var idx = gref.IndexOf("[d ref='", StringComparison.Ordinal);
        while (idx != -1) {
            var closingApostrophe = gref.IndexOf("'", idx + 8, StringComparison.Ordinal);
            var closingBrack = gref.IndexOf("]", closingApostrophe, StringComparison.Ordinal);
            gref = gref[..idx] +
                   gref.Substring(idx + 8, closingApostrophe - idx - 8) +
                   gref[(closingBrack + 1)..];
            idx = gref.IndexOf("[d ref='", StringComparison.Ordinal);
        }

        return gref;
    }

    private static List<string> GetDirectories(CASCFolder cascFolder) {
        return cascFolder.Entries.Keys.ToList();
    }

    private static bool IsDeathwingWorldBreakerAbility(CatalogCHeroHeroAbilArray abil) =>
        abil.Abil is "DeathwingLavaBurst" or "DeathwingEarthShatter";

    [GeneratedRegex(
        @"\b(in|at|on|of|by|with|into|from|during|before|after|under|over|between|among|to|through|across|up|down|for|about|like|as|a|an|the)\b",
        RegexOptions.IgnoreCase)]
    private static partial Regex UncapitalizeArticlesPrepositions();

    private void DoHero(Stream f, Dictionary<string, string> locStrings) {
        var ser = new XmlSerializer(typeof(Catalog));
        var catalog = (Catalog)ser.Deserialize(f)!;
        f.Seek(0, SeekOrigin.Begin);
        var xdoc = new XmlDocument();
        xdoc.Load(f);
        PopulateActorUnits(xdoc);
        var talentDic = catalog.CTalent.ToDictionary(x => x.id);
        var buttonDic = catalog.CButton.ToDictionary(x => x.id);
        foreach (var theHero in catalog.CHero.Where(x => x.TalentTreeArray != null)) {
            var heroName = locStrings[$"Hero/Name/{theHero.id}"];
            var abilities = theHero.HeroAbilArray;
            var talentTree = theHero.TalentTreeArray;

            switch (heroName) {
                case "Cho":
                case "Gall": {
                        var portraitPaired = xdoc.SelectSingleNode($"//CHero[@id='{theHero.id}']/PortraitPaired")?
                            .Attributes?["value"]?.Value;
                        HeroImages[heroName] = GetImage(portraitPaired ?? throw new InvalidOperationException("Can't find Cho/Gall hero portrait"));
                        break;
                    }
                case "Anduin":
                    HeroImages[heroName] = GetImage(@"Assets\Textures\ui_targetportrait_hero_anduin.dds");
                    break;
                default: {
                        var actorKey = $"Hero{theHero.id}";
                        if (ActorUnits.TryGetValue(actorKey, out var unit)) {
                            var heroImage = unit.HeroIcon ??
                                            GetImage(
                                                $@"Assets\Textures\ui_targetportrait_hero_{theHero.id.ToLower()}.dds");
                            HeroImages[heroName] = heroImage;
                        }
                        else {
                            HeroImages[heroName] = GetImage(
                                $@"Assets\Textures\ui_targetportrait_hero_{theHero.id.ToLower()}.dds");
                        }

                        break;
                    }
            }

            Console.WriteLine($"Doing hero {heroName}");
            // if (heroName != "Ana") {
            //     continue;
            // }

            var talentId = 0;
            var activeAbilities = 0;
            foreach (var talent in talentTree) {
                var talentKey = talent.Talent;
                CatalogCTalent? talentEntry = null;
                var talentName = "...";
                var talentDescription = "...";
                var iconPath = "...";
                if (talentDic.TryGetValue(talentKey, out var value)) {
                    talentEntry = value;
                    string iconKey;
                    if (talentEntry.Face.Count > 0) {
                        iconKey = talentEntry.Face[0].value;
                    }
                    else if (_talentGenericDic.TryGetValue(talentKey, out var value1)) {
                        talentEntry = value1;
                        iconKey = talentEntry.Face[0].value;
                    }
                    else {
                        throw new Exception("wtf");
                    }

                    var icon = buttonDic[iconKey];

                    talentName = (icon?.Name?.Count ?? 0) != 0
                        ? locStrings[icon!.Name![0].value]
                        : locStrings[$"Button/Name/{iconKey}"];

                    // talentName = locStrings[$"Button/Name/{iconKey}"];

                    if (icon?.Tooltip.Count > 1) {
                        Console.WriteLine("wtf?");
                    }

                    talentDescription = icon?.Tooltip.Count == 0
                        ? locStrings[$"Button/Tooltip/{iconKey}"]
                        : locStrings[icon!.Tooltip[0].value];

                    iconPath = icon.Icon[0].value;
                }
                else if (_talentGenericDic.TryGetValue(talentKey, out var value1)) {
                    talentEntry = value1;
                    var iconKey = talentEntry.Face[0].value;
                    var icon = _buttonGenericDic[iconKey];
                    talentName = locStrings[$"Button/Name/{iconKey}"];
                    talentDescription = locStrings[$"Button/Tooltip/{iconKey}"];
                    iconPath = icon.Icon[0].value;
                }

                if (talentEntry == null) {
                    continue;
                }

                // if (talentName != "Overdose") {
                //     continue;
                // }

                // ReSharper disable once UnusedVariable
                var imageBytes = GetImage(iconPath);

                Console.WriteLine($"Raw description {talentDescription}");
                var interpolatedDescription = InterpolateDescription(talentDescription, xdoc);
                Console.WriteLine($"Final description {interpolatedDescription}");

                // Console.WriteLine($"{talentName} -> {iconPath} -> {targetPngPath}\n{interpolatedDescription}");
                TalentInfoList.Add(
                    new TalentInfo {
                        TalentId = talentId++,
                        TalentIdString = talentKey,
                        TalentName = talentName,
                        TalentDescription = interpolatedDescription,
                        Column = int.Parse(talent.Column),
                        HeroName = heroName,
                        Tier = int.Parse(talent.Tier),
                        Image = imageBytes,
                    });

                if (talentEntry.Active.Any(x => x.value == "1") && talentEntry.Abil.Count > 0) {
                    var abilKey = talentEntry.Abil[0].value;
                    var heroic =
                        xdoc.SelectSingleNode($"//HeroAbilArray[@Abil='{abilKey}']/Flags[@index='Heroic']");
                    if (heroic != null) {
                        continue;
                    }

                    var cooldown = GetCooldown(xdoc, abilKey);
                    var key = "12345678".Substring(activeAbilities++, 1);
                    SkillInfoList.Add(
                        new SkillInfo {
                            HeroName = heroName,
                            SkillName = talentName,
                            Cooldown = cooldown,
                            Key = key,
                            Image = imageBytes,
                        });
                }
            }

            foreach (var abil in abilities) {
                // special cases for ignore
                if (abil.Abil == "AnaAimDownSightsDeactivate") {
                    continue;
                }

                if (abil.Flags is null) {
                    continue;
                }

                var buttonKey = abil.Button;
                if (buttonKey == null || !buttonDic.ContainsKey(buttonKey)) {
                    Console.WriteLine(
                        $"WARNING: Hero {heroName}, couldn't find button key {buttonKey} for ability {abil.Abil}");
                    continue;
                }

                var button = buttonDic[buttonKey];
                var buttonIcon = button.Icon[0].value;
                var abilName = (button.Name?.Count ?? 0) != 0
                    ? locStrings[button!.Name![0].value]
                    : locStrings[$"Button/Name/{buttonKey}"];

                var imageBytes = GetImage(buttonIcon);
                var abilKey = abil.Abil;
                if (abilKey is null) {
                    continue;
                }

                var xLayout = xdoc.SelectSingleNode($"//LayoutButtons[@Face='{buttonKey}']");

                string key;

                if (xLayout is null) {
                    if (abil.Abil is "GallTalentEyeOfKilrogg" or "NecromancerBoneArmor") {
                        key = "12345678".Substring(activeAbilities++, 1);
                    }
                    else {
                        continue;
                    }
                }
                else {
                    if (heroName is "Cho" or "Gall") {
                        // special cases for cho and gall
                        var parentUnit = xLayout.SelectSingleNode("./ancestor::CUnit");
                        if (parentUnit?.Attributes?["id"]?.Value != $"Hero{heroName}") {
                            continue;
                        }
                    }

                    var slot = xLayout.Attributes?["Slot"]?.Value;

                    switch (slot) {
                        case "Ability1":
                            key = "Q";
                            break;
                        case "Ability2":
                            key = "W";
                            break;
                        case "Ability3":
                            key = "E";
                            break;
                        case "Heroic":
                            key = "R";
                            break;
                        case "Trait":
                            key = "D";
                            break;
                        case "Mount":
                            key = "Z";
                            break;
                        case "Cancel":
                            continue;
                        default:
                            key = "zzz";
                            break;
                    }
                }

                var cooldown = GetCooldown(xdoc, abilKey);

                var existing =
                    SkillInfoList.SingleOrDefault(x => x.HeroName == heroName && x.SkillName == abilName);

                if (existing != null) {
                    if (cooldown > existing.Cooldown) {
                        existing.Cooldown = cooldown;
                    }
                }
                else {
                    SkillInfoList.Add(
                        new SkillInfo {
                            HeroName = heroName,
                            SkillName = abilName,
                            Cooldown = cooldown,
                            Key = key,
                            Image = imageBytes,
                        });
                }
            }
        }
    }

    private Stream? ExtractFile(CASCFile file) {
        try {
            return _casc.OpenFile(file.Hash);
        }
        catch (Exception exc) {
            Logger.WriteLine("Unable to extract file {0}: {1}", file.FullName, exc.Message);
            throw;
        }
    }

    private void GenerateTalentInfoDataTable() {
        var dt = new DataTable();
        dt.Columns.Add("HeroName", typeof(string));
        dt.Columns.Add("TalentIdString", typeof(string));
        dt.Columns.Add("TalentId", typeof(int));
        dt.Columns.Add("TalentName", typeof(string));
        dt.Columns.Add("TalentDescription", typeof(string));
        dt.Columns.Add("Tier", typeof(int));
        dt.Columns.Add("Column", typeof(int));

        foreach (var t in TalentInfoList) {
            dt.Rows.Add(
                t.HeroName,
                t.TalentIdString,
                t.TalentId,
                t.TalentName,
                t.TalentDescription,
                t.Tier,
                t.Column);
        }

        TalentInfoDataTable = dt;
    }

    private byte[] GetAllBytes(CASCFile cfIcon) {
        using var f = GetFileStream(cfIcon);
        using var reader = new BinaryReader(f ?? throw new InvalidOperationException($"Can't open {cfIcon.FullName}"));
        using var ms = new MemoryStream();
        const int bufferSize = 4096;
        var buffer = new byte[bufferSize];
        int count;
        while ((count = reader.Read(buffer, 0, buffer.Length)) != 0) {
            ms.Write(buffer, 0, count);
        }

        return ms.ToArray();
    }

    private Dictionary<string, string> GetAllGameStrings() {
        var locLines = Internal(_fldr);

        var locStrings = locLines.Select(x => x.Split('='))
            .DistinctBy(z => z[0])
            .ToDictionary(x => x[0], x => string.Join("=", x.Skip(1)));

        return locStrings;

        IEnumerable<string> Internal(CASCFolder fldr) {
            List<string> rc = [];
            if (fldr.GetEntry("GameStrings.txt") is CASCFile strings) {
                var lines = GetAllLines(strings);
                rc.AddRange(lines);
            }

            var subdirs = GetDirectories(fldr);
            foreach (var subdir in subdirs) {
                if (fldr.GetEntry(subdir) is CASCFolder cfDir) {
                    rc.AddRange(Internal(cfDir));
                }
            }

            return rc;
        }
    }

    private List<string> GetAllLines(CASCFile cascFile) {
        var cascLoc = CASCFolder.GetFiles(new[] { cascFile }).First();
        using var f = ExtractFile(cascLoc);
        var cascLines = ReadAllLines(f ?? throw new InvalidOperationException($"Can't open {cascLoc.FullName}")).ToList();
        return cascLines;
    }

    private void GetBaseHeroes() {
        var locLines = GetAllLines(_cfGameStrings);
        var locStringsLup = locLines
            .Select(x => x.Split('='))
            .ToLookup(x => x[0], x => string.Join("=", x.Skip(1)));
        var locStrings = locStringsLup.ToDictionary(x => x.Key, x => x.First());

        var heroesDirs = GetDirectories(_cfHeroes);

        foreach (var heroDir in heroesDirs) {
            var heroDirBare = Path.GetFileName(heroDir);
            var cfHeroDir = _cfHeroes.GetEntry(heroDir) as CASCFolder;
            if (cfHeroDir?.GetEntry($"{heroDirBare}.xml") is not CASCFile cfHero) {
                // Not a hero
                continue;
            }

            using var fn = GetFileStream(cfHero);
            DoHero(fn ?? throw new InvalidOperationException($"Can't open {cfHero.FullName}"), locStrings);
        }
    }

    private int GetCooldown(XmlNode xdoc, string abilKey) {
        if (abilKey == "HeroGenericSpellShield") {
            var refDoc = _referenceCatalog["Effect"];
            const string key = "HeroGenericSpellShieldApplyPlayerCooldown";
            var xCooldown2 = refDoc.SelectSingleNode($"//CEffectModifyPlayer[@id='{key}']/Cost")!;
            var xTimeUse = xCooldown2.SelectSingleNode("./Cooldown/TimeUse")!.Attributes!["value"]!.Value;
            return int.Parse(xTimeUse);
        }

        // special case for cooldown on activation/expiry only
        if (CooldownOnExpireAbilities.TryGetValue(abilKey, out var key1)) {
            var xCooldown = xdoc.SelectSingleNode($"//CEffectModifyUnit[@id='{key1}']/Cost");
            var cdMaybe = xCooldown?.Attributes?["CooldownTimeUse"]?.Value;
            if (cdMaybe == null) {
                var xCooldown2 = xdoc.SelectSingleNode($"//CEffectModifyPlayer[@id='{key1}']/Cost");
                if (xCooldown2 != null) {
                    var xTimeUse = xCooldown2.SelectSingleNode("./Cooldown/TimeUse")!.Attributes!["value"]!.Value;
                    return int.Parse(xTimeUse);
                }
            }
            else {
                return int.Parse(cdMaybe);
            }

            var xAbilEffect = xdoc.SelectSingleNode($"//CAbilEffectInstant[@id='{key1}']/Cost/Cooldown");
            if (xAbilEffect != null) {
                var xTimeUse = xAbilEffect.Attributes?["TimeUse"]?.Value;
                if (xTimeUse != null) {
                    return int.Parse(xTimeUse);
                }
            }

            throw new InvalidOperationException($"Couldn't determine cooldown for {abilKey}");
        }

        var specNodeList = xdoc.SelectNodes($"//*[@id='{abilKey}']");
        var genNodeList = _referenceCatalog["Abil"].SelectNodes($"//*[@id='{abilKey}']");
        var xAbilCandidates1 = specNodeList?.OfType<XmlNode>() ?? new List<XmlNode>();
        var xAbilCandidates2 = genNodeList?.OfType<XmlNode>() ?? new List<XmlNode>();
        var xAbilCandidates = xAbilCandidates1.Concat(xAbilCandidates2);

        foreach (var xAbil in xAbilCandidates) {
            int? GetValueOrConstant(string cdStringVal) {
                int? rc = null;
                if (cdStringVal.StartsWith('$')) {
                    cdStringVal = xAbil.SelectSingleNode($"//const[@id='{cdStringVal}']")!.Attributes!["value"]!.Value;
                }

                if (int.TryParse(cdStringVal, out var chargeCd)) {
                    rc = chargeCd;
                }

                return rc;
            }

            if (!xAbil.Name.StartsWith("CAbil")) {
                continue;
            }

            var chargeNode = xAbil.SelectSingleNode("./Cost/Charge/TimeUse");
            if (chargeNode != null) {
                var cdStringVal = chargeNode.Attributes!["value"]!.Value;
                return GetValueOrConstant(cdStringVal) ?? 0;
            }

            var cdNormalNode = xAbil.SelectSingleNode("./Cost/Cooldown");
            var cdOffNode = xAbil.SelectSingleNode("./OffCost/Cooldown");
            var cdExpireNode = xAbil.SelectSingleNode("./ExpireCost/Cooldown");

            var cdNodes = new[] { cdExpireNode, cdOffNode, cdNormalNode };
            foreach (var cdNode in cdNodes) {
                var cdStringVal = cdNode?.Attributes?["TimeUse"]?.Value;
                if (cdStringVal is null) {
                    continue;
                }

                return GetValueOrConstant(cdStringVal) ?? 0;
            }
        }

        return 0;
    }

    private Stream? GetFileStream(CASCFile cascFile) {
        var cascLoc = CASCFolder.GetFiles(new[] { cascFile }).First();
        return ExtractFile(cascLoc);
    }

    private byte[] GetImage(string cascPath) {
        var ddsPath = cascPath[16..]; // Skip Assets/Textures/
        if (_cfTextures.GetEntry(ddsPath) is not CASCFile cfIcon) {
            throw new Exception("where is it");
        }

        return GetAllBytes(cfIcon);
    }

    private void GetMapData() {
        var locStrings = _allGameStrings;

        using var f = GetFileStream(_cfMapData);
        if (f is null) {
            throw new InvalidOperationException($"Can't open {_cfMapData.FullName}");
        }

        f.Seek(0, SeekOrigin.Begin);
        var xdoc = new XmlDocument();
        xdoc.Load(f);
        var mapsWithImage = xdoc.SelectNodes("//DraftIntroImage/parent::CMap")!.OfType<XmlNode>().ToList();
        var cmapsDic = mapsWithImage.ToDictionary(r => r.Attributes!["id"]!.Value);
        foreach (var map in mapsWithImage) {
            var img = map.SelectSingleNode("./DraftIntroImage")!;
            var mapId = map.Attributes!["id"]!.Value;

            var nameNode = GetProp(map, "DraftIntroMapName")?.Attributes?["value"]?.Value ??
                           $"UI/MapLoadingScreen/{mapId}";

            var cascPath = img.Attributes!["value"]?.Value;

            if (cascPath is null) {
                continue;
            }

            var mapId1 = CamelCaseToSpaced().Replace(mapId, " $1");

            var mapName1 = locStrings.GetValueOrDefault(nameNode) ?? mapId1;

            var mapName = UncapitalizeArticlesPrepositions().Replace(mapName1, m => m.Value.ToLower());

            try {
                var imageBytes = GetImage(cascPath);
                MapImages[mapId] = imageBytes;
                MapNames[mapId] = mapName;
                MapInfoList.Add(new() {
                    Id = mapId,
                    Name = mapName,
                });
            }
            catch {
                Console.WriteLine($"Can't find image for map {mapName} ({cascPath})");
                /*ignored*/
            }

            continue;

            XmlNode? GetProp(XmlNode? d, string prop) {
                if (d is null) {
                    return null;
                }

                var child = d.SelectSingleNode($"./{prop}");

                if (child is not null) {
                    return child;
                }

                var parent = d.Attributes?["parent"]?.Value;
                return parent is null
                    ? null
                    : GetProp(cmapsDic.GetValueOrDefault(parent), prop);
            }
        }
    }

    private void GetModHeroes() {
        var heroesDirs = GetDirectories(_cfHeromods);

        foreach (var heroDir in heroesDirs) {
            var cfHeroDir = (CASCFolder)_cfHeromods.GetEntry(heroDir)!;
            var cfHeroEnusStormdata = (CASCFolder)cfHeroDir.GetEntry("enus.stormdata")!;
            var cfHeroLocalizedData = (CASCFolder)cfHeroEnusStormdata.GetEntry("LocalizedData")!;
            var cfHeroGameStrings = (CASCFile)cfHeroLocalizedData.GetEntry("GameStrings.txt")!;

            var locLines = GetAllLines(cfHeroGameStrings);
            var lookup = locLines.Select(x => x.Split('=')).ToLookup(r => r[0]);
            var odd = lookup.Where(r => r.Count() > 1).ToList();
            var locStrings = lookup
                .ToDictionary(x => x.Key, x => string.Join("=", x.First().Skip(1)));

            var cfHeroBaseStormdata = (CASCFolder)cfHeroDir.GetEntry("base.stormdata")!;

            if (cfHeroBaseStormdata.GetEntry("GameData.xml") is not CASCFile cfConfig) {
                // Not a hero
                continue;
            }

            var ser4 = new XmlSerializer(typeof(Includes));
            using var f4 = GetFileStream(cfConfig);
            var catalog4 = (Includes)ser4.Deserialize(f4 ?? throw new InvalidOperationException($"Can't open {cfConfig.FullName}"))!;

            var heroName = catalog4.Catalog[0].Path[9..]; // Skip GameData/
            var cfHeroGameData = (CASCFolder)cfHeroBaseStormdata.GetEntry("GameData")!;
            if (cfHeroGameData.GetEntry(heroName) is not CASCFile cfHero) {
                // Not a hero
                continue;
            }

            using var fn = GetFileStream(cfHero);
            DoHero(fn ?? throw new InvalidOperationException($"Can't open {cfHero.FullName}"), locStrings);
        }
    }

    private string InterpolateDescription(string talentDescription, XmlDocument catalog) {
        var doc = new HtmlDocument();
        doc.LoadHtml(talentDescription);
        var removeTags = new[] { "c", "img", "n" };
        foreach (var tag in removeTags) {
            var nodesForRemoval = doc.DocumentNode.SelectNodes($"//{tag}");
            if (nodesForRemoval != null) {
                foreach (var nodeToRemove in nodesForRemoval) {
                    if (nodeToRemove.HasChildNodes) {
                        var firstNewChild =
                            nodeToRemove.ParentNode.ReplaceChild(nodeToRemove.ChildNodes[0], nodeToRemove);
                        var cursor = firstNewChild;
                        for (var i = 1; i < nodeToRemove.ChildNodes.Count; i++) {
                            cursor = (nodeToRemove.ParentNode ?? doc.DocumentNode).InsertAfter(
                                nodeToRemove.ChildNodes[i],
                                cursor);
                        }
                    }
                    else {
                        var spaceNode = doc.CreateTextNode(" ");
                        nodeToRemove.ParentNode.ReplaceChild(spaceNode, nodeToRemove);
                    }
                }
            }
        }

        var dNodes = doc.DocumentNode.SelectNodes("//d");
        if (dNodes != null) {
            foreach (var dNode in dNodes) {
                var gref = dNode.Attributes["ref"]?.Value;
                var gconst = dNode.Attributes["const"]?.Value;
                var gscore = dNode.Attributes["score"];
                if (gref != null) {
                    gref = FixGref(gref);
                    var prec = int.Parse(dNode.Attributes["precision"]?.Value ?? "0");
                    var parsedRef = ParseRef(gref, catalog);
                    var fmt = "0." + new string(Enumerable.Range(0, prec).Select(_ => '#').ToArray());
                    var textNode = doc.CreateTextNode(parsedRef.ToString(fmt));
                    (dNode.ParentNode ?? doc.DocumentNode).ReplaceChild(textNode, dNode);
                }
                else if (gconst != null) {
                    var val = catalog.SelectSingleNode($"//const[@id='{gconst}']")?.Attributes?["value"]?.Value;
                    var textNode = doc.CreateTextNode(val);
                    (dNode.ParentNode ?? doc.DocumentNode).ReplaceChild(textNode, dNode);
                }
                else if (gscore != null) {
                    var textNode = doc.CreateTextNode("(stacks)");
                    (dNode.ParentNode ?? doc.DocumentNode).ReplaceChild(textNode, dNode);
                }
                else {
                    throw new InvalidDataException("Unknown placeholder string");
                    var textNode = doc.CreateTextNode("???");
                    (dNode.ParentNode ?? doc.DocumentNode).ReplaceChild(textNode, dNode);
                }
            }
        }

        var raw = doc.DocumentNode.OuterHtml;
        var trimmed = Regex.Replace(raw, @"\s+", " ").Trim();
        return trimmed;
    }

    private void OpenCasc() {
        (_casc, _fldr) = OpenStorage(GameInstallationPath);

        _allGameStrings = GetAllGameStrings();

        var cfVersions = (CASCFolder)_fldr.GetEntry("Versions")!;
        var versions = cfVersions.Entries.Values.Select(x => int.Parse(x.Name[4..])).ToList();
        BuildNumber = versions.Max();
        var cfSpecificVersion = (CASCFolder)cfVersions.GetEntry($"Base{BuildNumber}")!;
        var cfHeroesApp = (CASCFolder)cfSpecificVersion.GetEntry("Heroes.app")!;
        var cfContent = (CASCFolder)cfHeroesApp.GetEntry("Contents")!;
        var cfInfoPlist = (CASCFile)cfContent.GetEntry("Info.plist")!;
        using (var fnInfoPlist = GetFileStream(cfInfoPlist)) {
            var xmlDoc = new XmlDocument();
            xmlDoc.Load(fnInfoPlist ?? throw new InvalidOperationException($"Can't open {cfInfoPlist.FullName}"));

            var dict = xmlDoc.SelectSingleNode("//dict")!;
            foreach (XmlNode node in dict.ChildNodes) {
                if (node.InnerText == "BlizzardFileVersion") {
                    var nextNode = node.NextSibling!;
                    BuildVersion = nextNode.InnerText;
                }
            }
        }

        var cfMods = (CASCFolder)_fldr.GetEntry("mods")!;
        _cfHeromods = (CASCFolder)cfMods.GetEntry("heromods")!;

        var cfHeroesdataStormmod = (CASCFolder)cfMods.GetEntry("heroesdata.stormmod")!;
        var cfBaseStormdata = (CASCFolder)cfHeroesdataStormmod.GetEntry("base.stormdata")!;
        var cfGameData = (CASCFolder)cfBaseStormdata.GetEntry("GameData")!;

        var cfCoreStormmod = (CASCFolder)cfMods.GetEntry("core.stormmod")!;
        var cfCoreBaseStormdata = (CASCFolder)cfCoreStormmod.GetEntry("base.stormdata")!;
        var cfCoreGameData = (CASCFolder)cfCoreBaseStormdata.GetEntry("GameData")!;

        void MergeDocs(XmlDocument docDest, XmlDocument docSrc) {
            if (docSrc.DocumentElement?.ChildNodes == null) {
                return;
            }

            foreach (XmlNode childNode in docSrc.DocumentElement.ChildNodes) {
                docDest.DocumentElement?.AppendChild(docDest.ImportNode(childNode, true));
            }
        }

        void LoadDoc(string arg) {
            var name = $"{arg}Data.xml";
            var cfGeneric = cfGameData.GetEntry(name) as CASCFile;
            using var fn = GetFileStream(cfGeneric ?? throw new InvalidOperationException($"Can't open {name}"));
            _referenceCatalog[arg] = new XmlDocument();
            _referenceCatalog[arg].Load(fn ?? throw new InvalidOperationException($"Can't open {cfGeneric.FullName}"));

            var cfCore = cfCoreGameData.GetEntry(name) as CASCFile;
            using var fnCore = GetFileStream(cfCore ?? throw new InvalidOperationException($"Can't open {name}"));
            var coreDoc = new XmlDocument();
            coreDoc.Load(fnCore ?? throw new InvalidOperationException($"Can't open {cfCore.FullName}"));

            MergeDocs(_referenceCatalog[arg], coreDoc);
        }

        foreach (var entityType in EntityTypes) {
            LoadDoc(entityType);
        }

        // Load all from: mods\heromods\varian.stormmod\base.stormdata\GameData\*Data.xml
        {
        }

        _cfHeroes = (CASCFolder)cfGameData.GetEntry("Heroes")!;
        _cfButtonData = (CASCFile)cfGameData.GetEntry("ButtonData.xml")!;
        _cfTalentData = (CASCFile)cfGameData.GetEntry("TalentData.xml")!;
        _cfMapData = (CASCFile)cfGameData.GetEntry("MapData.xml")!;
        var cfEnusStormdata = (CASCFolder)cfHeroesdataStormmod.GetEntry("enus.stormdata")!;
        var cfLocalizedData = (CASCFolder)cfEnusStormdata.GetEntry("LocalizedData")!;
        _cfGameStrings = (CASCFile)cfLocalizedData.GetEntry("GameStrings.txt")!;
        var cfHeroesStormmod = (CASCFolder)cfMods.GetEntry("heroes.stormmod")!;
        var cfBaseStormassets = (CASCFolder)cfHeroesStormmod.GetEntry("base.stormassets")!;
        var cfAssets = (CASCFolder)cfBaseStormassets.GetEntry("Assets")!;
        _cfTextures = (CASCFolder)cfAssets.GetEntry("Textures")!;
    }

    private decimal ParseRef(string gref, XmlDocument catalog) {
        try {
            var sr = new StringReader(gref);
            var ais = new AntlrInputStream(sr);

            var lexer = new arithmeticLexer(ais);
            var tokenStream = new CommonTokenStream(lexer);
            var parser = new arithmeticParser(tokenStream);

            var context = parser.file();
            var visitor = new ExprVisitor(catalog, _referenceCatalog);

            return visitor.Visit(context).Value;
        }
        catch (Exception e) {
            Console.WriteLine(e);
            return 0;
        }
    }

    private void PopulateActorUnits(XmlDocument cata) {
        var globalActorUnits = cata.SelectNodes("//CActorUnit")!;
        foreach (XmlNode actorUnit in globalActorUnits) {
            var unitName = actorUnit?.Attributes?["unitName"]?.Value;
            if (unitName is null) {
                continue;
            }

            var xMinimapIcon = actorUnit!.SelectSingleNode("./MinimapIcon");
            var minimapIconPath = xMinimapIcon?.Attributes?["value"]?.Value;
            if (minimapIconPath != null) {
                var minimapIcon = GetImage(minimapIconPath);
                ActorUnits[unitName] = new ActorUnit {
                    MinimapIcon = minimapIcon,
                };
            }

            if (!unitName.StartsWith("Hero")) {
                continue;
            }

            var xHeroIcon = actorUnit.SelectSingleNode("./HeroIcon");
            var heroIconPath = xHeroIcon?.Attributes?["value"]?.Value;
            var substitutions = new Dictionary<string, string> {
                {
                    @"Assets\Textures\ui_mission_laserdrill_icon.dds",
                    @"Assets\Textures\storm_temp_ui_mission_laserdrill_icon.dds"
                }, {
                    @"Assets\Textures\ui_targetportrait_hero_MankirksWife.dds",
                    @"Assets\Textures\ui_targetportrait_hero_malganis.dds"
                },
            };
            if (heroIconPath != null) {
                if (substitutions.TryGetValue(heroIconPath, out var substitution)) {
                    heroIconPath = substitution;
                }

                var heroIcon = GetImage(heroIconPath);
                ActorUnits[unitName] = new ActorUnit {
                    HeroIcon = heroIcon,
                };
            }
        }
    }
}
